#!/bin/sh
# Chroot Booter - Main Init Script
# This is PID 1 in the bootstrap initramfs
# Supports: PXE boot, HTTP image loading, pivot_root, and return-to-bootstrap

export PATH=/bin:/sbin:/usr/bin:/usr/sbin
export PS1="[chroot-booter] \w # "

# Configuration (can be overridden by kernel cmdline)
IMAGE_URL=""
BOOTSTRAP_STATE=/var/run/bootstrap
RETURN_FIFO=/var/run/return-signal

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

log() {
    echo -e "${GREEN}[BOOT]${NC} $1"
}

warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Parse kernel command line for configuration
parse_cmdline() {
    log "Parsing kernel command line..."
    for arg in $(cat /proc/cmdline); do
        case "$arg" in
            image_url=*)
                IMAGE_URL="${arg#image_url=}"
                log "Image URL from cmdline: $IMAGE_URL"
                ;;
            bootstrap_debug)
                set -x
                log "Debug mode enabled"
                ;;
        esac
    done
}

# Mount essential filesystems
mount_essential() {
    log "Mounting essential filesystems..."
    
    mount -t proc none /proc 2>/dev/null || true
    mount -t sysfs none /sys 2>/dev/null || true
    mount -t devtmpfs none /dev 2>/dev/null || true
    mount -t tmpfs none /run 2>/dev/null || true
    mount -t tmpfs none /tmp 2>/dev/null || true
    
    # Create necessary device nodes if devtmpfs isn't available
    if [ ! -e /dev/console ]; then
        mknod -m 622 /dev/console c 5 1 2>/dev/null || true
        mknod -m 666 /dev/null c 1 3 2>/dev/null || true
        mknod -m 666 /dev/zero c 1 5 2>/dev/null || true
        mknod -m 666 /dev/random c 1 8 2>/dev/null || true
        mknod -m 666 /dev/urandom c 1 9 2>/dev/null || true
    fi
    
    # Ensure /dev/pts exists for terminal support
    mkdir -p /dev/pts
    mount -t devpts none /dev/pts 2>/dev/null || true
}

# Setup networking (required for HTTP image fetching)
setup_network() {
    log "Setting up network..."
    
    # Load network drivers
    modprobe e1000 2>/dev/null || true
    modprobe e1000e 2>/dev/null || true
    modprobe igb 2>/dev/null || true
    modprobe tg3 2>/dev/null || true
    modprobe r8169 2>/dev/null || true
    modprobe virtio_net 2>/dev/null || true
    modprobe vmxnet3 2>/dev/null || true
    
    # Wait a moment for interfaces to appear
    sleep 1
    
    # Bring up loopback
    ip link set lo up
    
    # Try to get IP via DHCP on all ethernet interfaces
    for iface in $(ls /sys/class/net/ | grep -v lo); do
        log "Configuring interface: $iface"
        ip link set "$iface" up 2>/dev/null || continue
        udhcpc -i "$iface" -n -q -t 3 -T 2 2>/dev/null && break
    done
    
    # Show network status
    ip addr show
}

# Create state directory for tracking bootstrap status
init_state() {
    log "Initializing bootstrap state..."
    mkdir -p "$BOOTSTRAP_STATE"
    mkdir -p "$(dirname $RETURN_FIFO)"
    
    # Create return signal FIFO
    [ -p "$RETURN_FIFO" ] || mkfifo "$RETURN_FIFO" 2>/dev/null || true
    
    # Mark initial state
    echo "bootstrap" > "$BOOTSTRAP_STATE/current_phase"
    echo "$(date)" > "$BOOTSTRAP_STATE/boot_time"
}

# Show interactive menu
show_menu() {
    echo ""
    echo "========================================"
    echo "  Chroot Booter - Bootstrap Console"
    echo "========================================"
    echo ""
    echo "Available commands:"
    echo "  load <url>     - Load and boot image from URL"
    echo "  return         - Return to bootstrap (if in target)"
    echo "  status         - Show current bootstrap status"
    echo "  shell          - Drop to shell"
    echo "  reboot         - Reboot system"
    echo "  poweroff       - Power off system"
    echo ""
    echo "Hotkey: Ctrl+Alt+F12 = Return to bootstrap"
    echo ""
}

# Load and pivot into target image
load_image() {
    local url="$1"
    
    if [ -z "$url" ]; then
        error "No URL specified"
        echo "Usage: load <http://server/path/to/image.tar.gz>"
        return 1
    fi
    
    log "Loading image from: $url"
    
    # Save URL for potential reload
    echo "$url" > "$BOOTSTRAP_STATE/last_image_url"
    
    # Call the chroot loader
    exec /bin/chroot-loader.sh "$url"
}

# Main bootstrap shell
bootstrap_shell() {
    local cmd
    local arg
    
    show_menu
    
    while true; do
        echo -n "[bootstrap] # "
        read cmd arg rest
        
        case "$cmd" in
            load)
                load_image "$arg"
                ;;
            return)
                if [ -f "$BOOTSTRAP_STATE/pid_in_target" ]; then
                    # Signal the return handler
                    echo "return" > "$RETURN_FIFO" 2>/dev/null || \
                        warn "Not currently in target system"
                else
                    warn "Not currently in target system"
                fi
                ;;
            status)
                echo "Current phase: $(cat $BOOTSTRAP_STATE/current_phase 2>/dev/null || echo 'unknown')"
                echo "Boot time: $(cat $BOOTSTRAP_STATE/boot_time 2>/dev/null || echo 'unknown')"
                if [ -f "$BOOTSTRAP_STATE/last_image_url" ]; then
                    echo "Last image: $(cat $BOOTSTRAP_STATE/last_image_url)"
                fi
                ;;
            shell)
                /bin/sh
                ;;
            reboot)
                log "Rebooting..."
                reboot -f
                ;;
            poweroff)
                log "Powering off..."
                poweroff -f
                ;;
            help)
                show_menu
                ;;
            "")
                # Empty command, just show prompt again
                ;;
            *)
                # Try to execute as external command
                if command -v "$cmd" >/dev/null 2>&1; then
                    $cmd $arg $rest
                else
                    error "Unknown command: $cmd"
                fi
                ;;
        esac
    done
}

# Cleanup and emergency shell on error
emergency_shell() {
    error "Entering emergency shell..."
    echo "Type 'exit' to continue boot attempt"
    /bin/sh
}

# Main initialization
main() {
    log "Chroot Booter initializing..."
    
    # Mount essential filesystems
    mount_essential
    
    # Parse kernel command line
    parse_cmdline
    
    # Setup network for HTTP access
    setup_network
    
    # Initialize state tracking
    init_state
    
    # Start hotkey daemon in background (for magic key detection)
    if [ -x /bin/hotkey-daemon.sh ]; then
        log "Starting hotkey daemon..."
        /bin/hotkey-daemon.sh &
    fi
    
    # If image URL was provided via kernel cmdline, load it automatically
    if [ -n "$IMAGE_URL" ]; then
        log "Auto-loading image from kernel cmdline..."
        sleep 2  # Give network time to settle
        load_image "$IMAGE_URL"
        # If load_image fails, we fall through to interactive mode
        warn "Auto-load failed, entering interactive mode"
    fi
    
    # Interactive bootstrap shell
    log "Entering interactive bootstrap mode"
    bootstrap_shell
    
    # Should never reach here, but just in case
    error "Bootstrap shell exited unexpectedly"
    emergency_shell
    reboot -f
}

# Run main
main
